<html>
<head>
<title>ST-JS: Borrowing Java's syntax to write type-safe
	JavaScript</title>
<link rel="stylesheet" type="text/css"
	href="http://fonts.googleapis.com/css?family=Ubuntu:regular,bold&subset=Latin">
<link rel="stylesheet" type="text/css"
	href="http://fonts.googleapis.com/css?family=Ubuntu Mono:regular,bold&subset=Latin">
<link rel="stylesheet" type="text/css" href="reset.css">
<link rel="stylesheet" type="text/css" href="index.css">
<link rel="stylesheet" type="text/css" href="960.css" />

<link href="prettify-theme.css" rel="stylesheet" type="text/css">
<script src="google-code-prettify/prettify.js" type="text/javascript"></script>


</head>
<body onload="prettyPrint()">

	<div class="topHighlight">
		<div class="container_12">
			<div class="grid_9">
				<h1>
					<a href="index.html">ST-JS : Strongly Typed JavaScript</a>
				</h1>
				<h2>Borrowing Java's syntax to write type-safe JavaScript</h2>
			</div>
		</div>
	</div>



	<div class="container_12 content">

		<div class="grid_2">
			<ul class="menu">
				<li><a href="gettingStarted.html">FAQ</a>
					<ul class="submenu">
						<li><a href="faq.html#whatIsStjs">What is ST-JS?</a></li>
						<li><a href="faq.html#whyStjs">Why ST-JS?</a></li>
						<li><a href="faq.html#whyNotGwt">Why not GWT / TypeScript
								/ etc...?</a></li>
						<li><a href="faq.html#shouldIUseIt">Should I use it?</a></li>
						<li><a href="faq.html#howDoesItWork">How does it work?</a></li>
						<li><a href="faq.html#whatDoesItLookLike">What does it
								look like?</a></li>
						<li><a href="faq.html#limitations">Limitations</a></li>
					</ul></li>
				<li><a href="download.html">Download</a></li>
				<li><a href="tutorial.html">Tutorial</a></li>
				<li><a href="reference.html">Reference</a>
					<ul class="submenu">
						<li><a href="">Writing ST-JS code</a></li>
						<li><a href="jslib.html">JavaScript bridge</a></li>
						<li><a href="jslib.html">DOM bridge</a></li>
						<li><a href="bridges.html">Library bridges</a></li>
						<li><a href="">Generator</a></li>
						<li><a href="maven.html">Maven plugin</a></li>
						<li><a href="eclipse.html">Eclipse integration</a></li>
						<li><a href="junit.html">JUnit runner</a></li>
					</ul></li>
				<li><a href="team.html">Team</a></li>
				<li><a href="http://axcraciun.wordpress.com/">Blog</a></li>
			</ul>
		</div>

		<div class="grid_10">
			<h3>Writing ST-JS code</h3>
			<p>
				For an quick overview of the basics of writing ST-JS code, check out
				our <a href="faq.html#whatDoesItLookLike">"What does it look
					like?"</a> section. For more detailed information, keep reading.
			<h4>Controlling the JavaScript output</h4>
			<p>In most cases, there is no need to change the way the
				JavaScript is generated. There are however come cases where this is
				useful</p>
			<p>ST-JS lets you customize the way the JavaScript is generated
				(if you want to). You can give hints to the generator by placing
				annotations in your Java code.</p>
				
				
			<h5>@Namespace</h5>
			<p>The annotated Class, or all the classes in the annotated package
				will be placed in the specified namespace. This is useful to avoid
				name clashes with classes coming from other libraries.</p>

			<div class="grid_5 alpha">
<pre class="code prettyprint language-java">
// Java with @Namespace
@Namespace("genie.in.a")
public class Bottle {
    public Bottle() {
        doSomething();
    }
}


// Java without @Namespace
public class Plain {
    public Plain() {
        doNothing();
    }
}
</pre>
			</div>
			<div class="grid_5 omega">
<pre class="code prettyprint language-javascript">
// JavaScript with @Namespace
stjs.ns("genie.in.a");

genie.in.a.Bottle = function() {
    doSomething();
}



// JavaScript without @Namespace
Plain = function() {
    doNothing();
}
</pre>
			</div>
			<div class="clear"></div>
			


			<h5>@JavascriptFunction</h5>
			<p>All the anonymous implementations of the annotated single-method Java interface 
			will be generated as a JavaScript anonymous function. All invocations of the method
			contained in the annotated interface will be generated as a direct call to that function.
			The interface itself will not be generated in Javascript
			
			
			<div class="grid_5 alpha">
<pre class="code prettyprint language-java">
// Java
@JavascriptFunction
public interface EventHandler {
    public boolean onEvent(Event evt);
}

public class Something {
    public Something(Event event){
        // defining a new anonymous implementation
        EventHandler handler = new EventHandler() {
            public boolean onEvent(Event evt){
                console.print(evt.name);
            }
        };
        
        // calling the single-method
        handler.onEvent(event);
    }
}
</pre>
			</div>
			<div class="grid_5 omega">
<pre class="code prettyprint language-javascript">
// JavaScript 


// the interface is not generated



Something = function(event){
    // translated as an anonymous function
    var handler = function(evt) {

        console.print(evt.name);
        
    };
    
    // invoke the function directly
    handler(event);
}
</pre>
			</div>
			<div class="clear"></div>
			
			<h5>@GlobalScope</h5>
			<p>The static fields and methods in the annotated type are considered
				part of the global scope during JavaScript generation. When a type is 
				annotated with @GlobalScope, no corresponding JavaScript is generated.
			</p>
			<p>This annotation is useful when writing bridges for an existing JavaScript 
				library which declares some of its members in the global scope (typical 
				example: the $ identifier for JQuery). org.stjs.javascript.Global is an
				example of class with this annotation, which contains the declaration 
				of several global objects such as "window" or "console". 
			</p>

			<div class="grid_5 alpha">
<pre class="code prettyprint language-java">
// Java (declaration)
@GlobalScope
public class JQuerySubset {
    public static JQuery $;
    public static JQuery $(String selector) {
        // this doesn't need to be implemented
        // the real implementation comes 
        // directly from jquery.js
        throw new UnsupportedOperationException();
    }
}

// Java (usage)
import static JQuerySubset.$;

public class Something {
    public Something(){
        $(".hello").addClass(".world");
    }
}
</pre>
			</div>
			<div class="grid_5 omega">
<pre class="code prettyprint language-javascript">
// JavaScript (declaration)


// nothing is generated, implementation comes from
// including jquery.js






// JavaScript (usage)



Something = new function(){
    $(".hello").addClass(".world");
}
</pre>
			</div>
			<div class="clear"></div>


			<h5>@SyntheticType</h5>
			<p>The annotated class is marked as a data object. Objects marked with 
				this annotation can only contain non-private fields and cannot 
				contain any methods. Instance of a class marked with this annotation
				can be initialized using the double-brace syntax in your java source
				code, and will be translated to a Javascript Object Literal. No
				JavaScript code is generated for classes marked with this annotation.
			</p>
			<p>This annotation is typically used by bridges to provide a correctly typed 
				equivalent of a parameter that the javscript library expects to be an 
				Object Literal. An example is AjaxParams used by JQuery.ajax</p>

			<div class="grid_5 alpha">
<pre class="code prettyprint language-java">
// Java (declaration)
@SyntheticType
public class AjaxParams {
    // some fields are omitted for brevity
    public boolean async;
    public String url;
}

// Java (usage)
import static JQuerySubset.$;

public class Something {
    public Something(){
        $.ajax(new AjaxParams(){{
            async = false;
            url = "http://example.com";
        }});
    }
}
</pre>
			</div>
			<div class="grid_5 omega">
<pre class="code prettyprint language-javascript">
// JavaScript (declaration)


// nothing is generated




// JavaScript (usage)



Something = function(){
    $.ajax({
        async : false,
        url : "http://example.com"
    });
}
</pre>
			</div>
			<div class="clear"></div>

			<h5>@STJSBridge</h5>
			<p>mark a type as STJS bridge, so it can be used in the code for
				generation.</p>

			<h5>@Adapter</h5>
			<p>useful when writing bridges for existent JavaScript types.
				These are classes that are used to supply methods for Java types
				when they don't have a method that their JavaScript counterpart has.
				For example for Number in JavaScript you can do number.toFixed(2).
				As in Java this method does not exist and as the Java Number-derived
				classes are all final, the only alternative is to put this method in
				another class - an adapter class. All the methods of an adapter
				class must have their first parameter the object to which the method
				is applied. The other parameters are the parameters normally
				supplied to the JavaScript method.</p>


			<h5>@Template</h5>
			<p>this annotation can be used on a method to control how the
				call to this method will be generated. The parameter taken by this
				annotation is a name of a defined template. Currently only
				@Template("none") is defined, that leaves a method call as-is.
				object.$get(i) for example will generate object.$get(i) instead of
				object[i].</p>

			<h4>Special fields and methods</h4>
			<p>Most of the Java code you write will be translated basically
				as-is to its JavaScript counterpart. However, there are some
				JavaScript constructs that cannot be written as-is in Java. For
				these cases, ST-JS provides workarounds as special fields and
				methods.</p>
			<p>All of those special fields and methods are easy to identify:
				there name always starts with the dollar sign ($). When you use
				these methods you should expect the generated JavaScript code to
				look slighty different (it is usually prettier, actually) than the
				corresponding Java construct.</p>
			<p>Here is the list of these constructs and methods:
			<table class="specialMethods">
				<tr>
					<th>Java</th>
					<th>JavaScript</th>
					<th>Description</th>
				</tr>
				<tr>
					<th colspan="3">org.stjs.javascript.JSCollections</th>
				</tr>
				<tr>
					<td class="java">$map(k1,v1,k2,v2)</td>
					<td class="js">{k1:v1, k2:v2}</td>
					<td class="desc">Create a map with the given keys and values</td>
				</tr>
				<tr>
					<td class="java">$array(a, b, c)</td>
					<td class="js">[a, b, c]</td>
					<td class="desc">Create an array with the given items</td>
				</tr>
				<tr>
					<td class="java">Array&lt;T&gt; a = $castArray(T[]b)</td>
					<td class="js">var a=b</td>
					<td class="desc">See a java array as the
						org.stjs.javascript.Array type</td>
				</tr>
				<tr>
					<th colspan="3">org.stjs.javascript.Map</th>
				</tr>
				<tr>
					<td class="java">x.$put(a, b)</td>
					<td class="js">x[a] = b</td>
					<td class="desc">Put a key and a value in a map</td>
				</tr>
				<tr>
					<td class="java">x.$get(a)</td>
					<td class="js">x[a]</td>
					<td class="desc">Retrieve a value from a map</td>
				</tr>
				<tr>
					<td class="java">x.$delete(a)</td>
					<td class="js">delete x[a]</td>
					<td class="desc">Delete an entry from a map</td>
				</tr>
				<tr>
					<th colspan="3">org.stjs.javascript.Array</th>
				</tr>
				<tr>
					<td class="java">x.$get(a)</td>
					<td class="js">x[a]</td>
					<td class="desc">Retrieve an item from an array</td>
				</tr>
				<tr>
					<td class="java">x.$set(index, val)</td>
					<td class="js">x[index] = val</td>
					<td class="desc">Modify an item in an array</td>
				</tr>

				<tr>
					<th colspan="3">org.stjs.javascript.JsObjectAdapter</th>
				</tr>
				<tr>
					<td class="java">propsMap = $properties(obj)</td>
					<td class="js">propsMap = obj</td>
					<td class="desc">see an object as a map of its properties</td>
				</tr>
				<tr>
					<td class="java">T obj = $object(map)</td>
					<td class="js">var obj = map</td>
					<td class="desc">see map as an object of a given type with the
						same properties</td>
				</tr>
				<tr>
					<td class="java">$prototype(obj)</td>
					<td class="js">obj.prototype</td>
					<td class="desc">Return the prototype of a JavaScript object</td>
				</tr>
				<tr>
					<td class="java">$constructor(obj)</td>
					<td class="js">obj.constructor</td>
					<td class="desc">Return the constructor of a JavaScript object</td>
				</tr>
				<tr>
					<td class="java">$js(javascriptCode)</td>
					<td class="js">javascriptCode</td>
					<td class="desc">Replaces with the given javascriptCode (only
						String literals accepted). Use it only in extreme cases as it
						makes it impossible to minimize the code.</td>
				</tr>
				<tr>
					<th colspan="3">org.stjs.javascript.Global</th>
				</tr>
				<tr>
					<td class="java">$or(a,b,c)</td>
					<td class="js">a || b || c</td>
					<td class="desc">Return first value the is equivalent to true
						in JavaScript</td>
				</tr>
			</table>



			When writing STJS bridges as Java interfaces (like the jQuery one is
			done), you have sometimes the need to expose a field, thing that is
			not possible with Java interfaces. So imagine you have a JavaScript
			code:
			<pre class="brush: java">
var A = {
	field: null,
	method: function(){
	}
}
</pre>

			and you'd like to create an STJS bridge (so that you can use it in
			Java) and you want to do it as Java interface (you can also do it as
			a normal class). As you cannot have:
			<pre class="brush: java">
public interface A {
	public String field;
	public String method();
}
</pre>

			what you can do is:
			<pre class="brush: java">
public interface A{
	public String $field();
	public void $field(String s); //don't add, if the field is read-only
	public String method();
}
</pre>

			The code <i>a.$field("abc")</i> will be correctly translated to <i>a.field
				= "abc"</i> <br /> If you wanted, for example to keep the call to the <i>field</i>
			method as is, you could've used the @Template("none") annotation on
			the method, like the following code:

			<pre class="brush: java">
public interface A{
	public String $field();
	@Template("none")
	public void $field(String s); //don't add, if the field is read-only
	public String method();
}
</pre>

			So now the code <i>a.$field("abc")</i> will be translated to <i>a.$field("abc")</i>

			<br /> In the next major version we'd like to use the @Template
			mechanism instead of the method's name in order to control how the
			code is generated.
			</p>

















			<div id="content">
				<h1>Documentation</h1>

				<h2>Maven plugin</h2>
				<p>You can activate separately the JavaScript generation for
					main sources and tests. Here are the goals of the maven plugin:
				<ul>
					<li><b>generate</b> - activate the generation for the main
						sources (in the "process-sources" phase)</li>
					<li><b>generate-test</b> - activate the generation for the
						test sources (in the "process-test-classes" phase)</li>
					<li><b>copy-js</b> - copies the JavaScript files (either
						generated or just bridged) from the dependencies to the final
						artifact (war file), so that they can be used in the web pages</li>
				</ul>
				There are some parameters that can be used to configure the plugin:
				<ul>
					<li><b>includes/include</b> - the path specifier describing
						for what Java source you want to generate JavaScript. It's the
						standard path Maven/Ant specifiers. Defaults to **.</li>
					<li><b>excludes/excludes</b> - the path specifier describing
						what Java source you want to exclude from the JavaScript generate.
						It's the standard path Maven/Ant specifiers. Defaults to ""
						(nothing).</li>
					<li><b>allowedPackages</b> - it's a list of Java packages that
						are allowed to be used inside the Java sources used for
						generation. A common usage is when you reserved in the Java
						sources a package for bridges to some JavaScript libraries. This
						package should than be excluded from the generation process.</li>
					<li><b>generateArrayHasOwnProperty</b> - true to generate
						inside each array iteration if (!array.hasOwnProperty(index))
						continue; in order to protect array iteration from the inclusion
						of the methods added to Array's prototype. Default value if true</li>
					<li><b>pack</b> - if true, a single JavaScript will be created
						containing all the generated JavaScript files in a correct order
						(follows the dependencies)</li>
				</ul>
				</p>

				<!-- ------------------------  -->
				<h2>STJS helper</h2>
				<p>The org.stjs.javascript.stjs.STJS interface is the bridge to
					the JavaScript code coming with the generator. It offers some
					helpers for different type inexistent in JavaScript:
				<ul>
					<li><b>boolean isEnum(obj)</b> - return true if the given
						JavaScript object is an enum entry (the JavaScript wrapper needed
						to allow the usage of Java enums)</li>
					<li><b>Exception exception(Object obj)</b> - allows you in
						Java to use any object as an exception. At runtime, the executed
						JavaScript code will return exactly the received parameter</li>
					<li><b>public &lt;T&gt; T parseJSON(String json,
							Class&lt;T&gt; clazz)</b> - parses a JSON string in a "type-safe"
						manner by creating the object hierarchy using the given type
						definition</li>
				</ul>
				</p>
				<!-- ------------------------  -->
				<h2>JUnit runner configuration</h2>

				<p>The STJS JUnit runner runs your unit tests in one or multiple
					browsers of your chosing. To do so, it builds an HTML page that
					includes all the necessary HTML and javascript necessary to execute
					your tests and return the result to JUnit. The HTML page that will
					be sent to the browser includes the following things:
				<ul>
					<li>The javascript version of all the classes that are being
						tested, as well as that of all classes they depend on.</li>
					<li>If any bridge class or interface is used, the javascript
						code that corresponds. For example, if the classes under test use
						jQuery 1.7.1, then jQuery-1.7.1.js is imported in the HTML page
						that is sent to the browser.</li>
					<li>If specified with the <b>@ScriptsBefore</b> or <b>@ScriptsAfter</b>
						annotations, a set of javascript files that are required for the
						tests to pass but that are not declared as a STJS bridge class or
						interface.
					</li>
					<li>If specified with the <b>@HtmlFixture</b> annotation, a
						fragment of HTML that is required for the tests to pass.
					</li>
				</ul>
				</p>

				<p>Before using the JUnit runner you have to add the dependency
					to your projects pom.xml:</p>
				<pre class="brush: xml">
&lt;dependency&gt;
  &lt;groupId&gt;org.st-js&lt;/groupId&gt;
  &lt;artifactId&gt;test-helper&lt;/artifactId&gt;
  &lt;version&gt;${stjs.version}&lt;/version&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</pre>

				<p>
					To activate the STJS JUnit runner you have to annotate your JUnit
					test classes this way: <b>@RunWith(STJSTestDriverRunner.class)</b>.
				</p>

				<p>
					Besides the standard JUnit annotations such as <b>@Test</b>, <b>@Before</b>,
					<b>@After</b>, the STJSTestDriverRunner supports several other
					custom annotations.
				</p>

				<ul>
					<li>
						<p>
							<b>@HtmlFixture</b> is an optional annotation that can be applied
							to your test class, and is used to force the STJSTestDriverRunner
							to include a specific HTML fragment on the page. If the fragment
							is short enough, it can be specified verbatim in the annotation.
						</p> <pre class="brush: java">
@RunWith(STJSTestDriverRunner.class)
@HtmlFixture("&lt;div id='importantContainer'&gt;&lt;/div&gt;")
public class TestSimpleFixture {
	...
}</pre>
						<p>If the fragment is longer the annotation can specify a path
							to a classpath resource that contains the HTML code. Then html
							fragment file will be looked up using
							ClassLoader.getResourceAsStream(). This means that
							STJSTestDriverRunner (trough the ClassLoader) will first attempt
							to find the file in your class path. If the file cannot be found
							in your classpath, then STJSTestDriverRunner will look for the
							file starting at the "document root" or your webapp, if any. For
							a typical maven project, this means it will first look in
							/target/WEB-INF/classes, and then in /target.</p> <pre
							class="brush: java">
@RunWith(STJSTestDriverRunner.class)
@HtmlFixture(url = "/SomeComplexHtmlFragment.html")
public class TestSimpleFixture {
	...
}</pre>
					</li>
					<li>
						<p>
							<b>@ScriptsBefore</b> and <b>@ScriptsAfter</b> are optional
							annotations that can be applied to your test class, and are used
							to force the STJSTestDriverRunner to include extra javascript
							files in the &lt;head&gt; section of the HTML page that is sent
							to the browser. Script files specified in <b>@ScriptsBefore</b>
							will be included in the HTML page before the class under test and
							all its dependencies. Script files specifed in <b>@ScriptsAfter</b>
							will be included in the HTML page after the class under test and
							all its dependencies.
						</p>
						<p>Each of the strings passed as a value to these annotations
							will be used verbatim in the generated HTML. This means that you
							can pass either a path to a javascript file that exists within
							your project, or one that resides on another domain.</p> <pre
							class="brush: java">
@RunWith(STJSTestDriverRunner.class)
@ScriptsBefore({"/someLibBefore.js"})
@ScriptsAfter({"http://example.com/someLibAfter.js"})
public class TestHelloWorld {
	...
}</pre>
						<p>Will generate the following fragment of HTML</p> <pre
							class="brush: xml">
&lt;head&gt;
  &lt;!-- contents of @ScriptsBefore --&gt;
  &lt;script src="/someLibBefore.js" type="text/javascript"&gt;&lt;/script&gt;
  
  &lt;!-- Class under test plus other stuff required by stjs  --&gt;
  &lt;script src="/stjs.js" type="text/javascript"&gt;&lt;/script&gt;
  &lt;script src="/HelloWorld.js" type="text/javascript"&gt;&lt;/script&gt;
  
  &lt;!-- contents of @ScriptsAfter --&gt;
  &lt;script src="http://example.com/someLibAfter.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;/head&gt;
</pre>
						<p>If the script passed to this annotation is a reference to a
							file defined in your project (ie: it doesn't start with a
							protocol handler such as http:, file:, ftp:, https:, etc...),
							then the script file will be looked up using
							ClassLoader.getResourceAsStream(). This means that
							STJSTestDriverRunner (trough the ClassLoader) will first attempt
							to find the file in your class path. If the file cannot be found
							in your classpath, then STJSTestDriverRunner will look for the
							file starting at the "document root" or your webapp, if any. For
							a typical maven project, this means it will first look in
							/target/WEB-INF/classes, and then in /target.</p>
					</li>
				</ul>

				<p>
					You can configure some of the test driver's parameters in a file
					called <b>stjs-test.properties</b> that must be placed the root of
					your class path. The properties supported by this file are the
					following:
				</p>

				<table class="methods">
					<tr>
						<th>property</th>
						<th>description</th>
					</tr>
					<tr>
						<td><b>stjs.test.config</b></td>
						<td>The classpath location of properties file that contains
							the stjs test driver configuration. Default value is
							"/stjs-test.properties"</td>
					</tr>
					<tr>
						<td><b>stjs.test.browsers</b></td>
						<td>A comma separated list of browsers on which to run the
							tests. A test is successful only if it has been run successfully
							on all the browsers in this list. See the table below for a
							description of the supported browsers. The default value is
							"desktopDefault".</td>
					</tr>
					<tr>
						<td><b>stjs.test.port</b></td>
						<td>the port opened by the test driver waiting for connection
							from the browsers. Default value is 8055</td>
					</tr>
					<tr>
						<td><b>stjs.test.wait</b></td>
						<td>the time (in seconds) the test driver waits for the
							number of configured browsers to connect. Default value is 10</td>
					</tr>
					<tr>
						<td><b>stjs.test.skipIfNoBrowser</b></td>
						<td>if this is true, if no browser was connected that it
							considers the tests as ignored (can be used in some batch
							processing, without failing completely the tests). Default value
							is false</td>
					</tr>
					<tr>
						<td><b>stjs.test.startBrowser</b></td>
						<td>if true, if after 2 seconds (normally check of the
							client's code check is 1 second) no browser connected to the test
							driver, it tries to start the system's default browser. This can
							only work is the Desktop.isDesktopSupported() check return true
							(so usually a developer's machine). Default value is true</td>
					</tr>
					<tr>
						<td><b>stjs.test.testTimeout</b></td>
						<td>the time (in seconds) the test driver waits for a test to
							return a result from the browser. Passed this time the test is
							considered failed. Default value is 2 seconds</td>
					</tr>
					<tr>
						<td><b>stjs.test.debug</b></td>
						<td>if this is true, debug information is displayed. Default
							value is false</td>
					</tr>
					<tr>
						<td><b>firefox.bin</b></td>
						<td>the path to the binary of firefox (see "firefox" in the
							table below)</td>
					</tr>
					<tr>
						<td><b>chrome.bin</b></td>
						<td>the path to the binary of Google Chrome or chromium (see
							"chrome" in the table below)</td>
					</tr>
					<tr>
						<td><b>phantomjs.bin</b></td>
						<td>the path to the binary of phantomjs (see "phantomjs" in
							the table below)</td>
					</tr>
				</table>
				<p>All these properties can be overridden by specifying them as
					system properties when launching the java vm. For example to force
					debug mode when launching the tests via Maven you can run `mvn test
					-Dstjs.test.debug=true`.</p>
				<p>The browsers that can be added to the stjs.test.browsers
					property are the following.</p>

				<table class="methods">
					<tr>
						<th colspan="2">Browsers that require a graphics system</th>
					</tr>
					<tr>
						<th>Name</th>
						<th>Description</th>
					</tr>
					<tr>
						<td><b>desktopDefault</b></td>
						<td>
							<p>Launches whichever browser is the default for the desktop
								on which the tests are running.</p>
							<p>On windows the browser is launched using
								Desktop.getDesktop().browse(). On other systems it is launched
								using the "xdg-open" utility. This browser might fail to launch
								on headless machines in some operating systems, for example a
								linux server without an X11 server.</p>
						</td>
					</tr>
					<tr>
						<td><b>firefox</b></td>
						<td>
							<p>Launches firefox.</p>
							<p>STJS will look in the common firefox installation
								directories to find the binary. If firefox is not installed in
								the standard location on your target system, you can specify the
								path of the binary in the firefox.bin property in
								"stjs-test.properties", in whichever file you specified in the
								stjs.test.config system property or on the command line.</p>
						</td>
					</tr>
					<tr>
						<td><b>chrome</b></td>
						<td>
							<p>Launches Goole Chrome (or chromium).</p>
							<p>STJS will look in the common chrome installation
								directories to find the binary. If chrome is not installed in
								the standard location on your target system, you can specify the
								path of the binary in the chrome.bin property in
								"stjs-test.properties", in whichever file you specified in the
								stjs.test.config system property or on the command line.</p>
						</td>
					</tr>
					<tr>
						<th colspan="2">Browsers that can run on headless systems</th>
					</tr>
					<tr>
						<th>Name</th>
						<th>Description</th>
					</tr>
					<tr>
						<td><b>rhino</b></td>
						<td>
							<p>Runs the tests in an instance of Rhino that is embedded in
								stjs' test runner.</p>
							<p>No additional software needs to be installed on the target
								system for this browser to run.</p>
						</td>
					</tr>
					<tr>
						<td><b>remote</b></td>
						<td>
							<p>Doesn't launch any browsers.</p>
							<p>It assumes that a browser is already running somewhere
								(potentially on a remote machine), and that this browsers
								periodically polls the stjs test runners HTTP port to fetch unit
								tests to run.</p>
						</td>
					</tr>
					<tr>
						<td><b>phantomjs</b></td>
						<td>
							<p>Launches all the tests in phantomjs.</p>
							<p>Phantomjs is a lightweight, headless browser based on
								webkit and V8. Phantomjs needs to be installed on the target
								system for this browser to run.</p>
							<p>STJS will look in the common phantomjs installation
								directories to find the binary. If phantomjs is not installed in
								the standard location on your target system, you can specify the
								path of the binary in the phantomjs.bin property in
								"stjs-test.properties", in whichever file you specified in the
								stjs.test.config system property or on the command line.</p>
						</td>
					</tr>
					<tr>
						<td><b>headlessFirefox</b></td>
						<td>
							<p>Only supported on systems that use an X11 server.</p>
							<p>This browser needs Xvfb and firefox to be installed on the
								target system. Xvfb (X Virutal Frame Buffer) is an X11 server
								that doesn't need any real graphics capability to run, and will
								happily run on servers that do not have a graphics card.</p>
							<p>This browser will first launch an instance of Xvfb, and
								then launch a firefox instance instructing it to use Xvfb as its
								display.</p>
							<p>Xvfb is expcted to be in your PATH. The path to the
								firefox binary can be configured in the same way as for the
								"firefox" browser.</p>
						</td>
					</tr>
					<tr>
						<td><b>headlessChrome</b></td>
						<td>Same as headlessFirefox but starts Google Chrome instead.</td>
					</tr>
				</table>

				<!-- ------------------------  -->
				<h2>JavaScript, DOM and jQuery documentation</h2>
				<p>STJS provides bridges for the basic JavaScript objects, the
					DOM objects, jQuery (1.6) and jQuery UI (1.8). The bridges follow
					as closely as possible their JavaScript counterpart. So for the
					moment, please use the documentation provided by other reference
					websites:
				<ul>
					<li>JavaScript and DOM - <a
						href="http://www.w3schools.com/jsref/default.asp" target="_blank">w3schools</a></li>
					<li>jQuery - <a href="http://docs.jquery.com" target="_blank">jQuery</a></li>
					<li>jQuery UI - <a href="http://jqueryui.com/demos/"
						target="_blank">jQuery UI</a></li>
				</ul>

				For JavaScript and DOM the global functions and objects (like
				setInterval or window) are found in the <b>org.stjs.javascript.Global</b>
				class.<br /> For jQuery, the $ object and function are found in the
				<b>org.stjs.javascript.jquery.GlobalJQuery</b> class.
				</p>








			</div>
		</div>

		<a href="https://github.com/st-js/st-js/"><img
			style="position: absolute; top: 0; left: 0; border: 0;"
			src="https://s3.amazonaws.com/github/ribbons/forkme_left_white_ffffff.png"
			alt="Fork me on GitHub"></a>
</body>
</html>


