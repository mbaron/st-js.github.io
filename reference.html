<html>
<head>
<title>ST-JS: Borrowing Java's syntax to write type-safe
	JavaScript</title>
<link rel="stylesheet" type="text/css"
	href="http://fonts.googleapis.com/css?family=Ubuntu:regular,bold&subset=Latin">
<link rel="stylesheet" type="text/css"
	href="http://fonts.googleapis.com/css?family=Ubuntu Mono:regular,bold&subset=Latin">
<link rel="stylesheet" type="text/css" href="reset.css">
<link rel="stylesheet" type="text/css" href="index.css">
<link rel="stylesheet" type="text/css" href="960.css" />

<link href="prettify-theme.css" rel="stylesheet" type="text/css">
<script src="google-code-prettify/prettify.js" type="text/javascript"></script>


</head>
<body onload="prettyPrint()">

	<div class="topHighlight">
		<div class="container_12">
			<div class="grid_9">
				<h1>
					<a href="index.html">ST-JS : Strongly Typed JavaScript</a>
				</h1>
				<h2>Borrowing Java's syntax to write type-safe JavaScript</h2>
			</div>
		</div>
	</div>



	<div class="container_12 content">

		<div class="grid_2">
			<ul class="menu">
				<li><a href="gettingStarted.html">FAQ</a>
					<ul class="submenu">
						<li><a href="faq.html#whatIsStjs">What is ST-JS?</a></li>
						<li><a href="faq.html#whyStjs">Why ST-JS?</a></li>
						<li><a href="faq.html#whyNotGwt">Why not GWT / TypeScript
								/ etc...?</a></li>
						<li><a href="faq.html#shouldIUseIt">Should I use it?</a></li>
						<li><a href="faq.html#howDoesItWork">How does it work?</a></li>
						<li><a href="faq.html#whatDoesItLookLike">What does it
								look like?</a></li>
						<li><a href="faq.html#limitations">Limitations</a></li>
					</ul></li>
				<li><a href="download.html">Download</a></li>
				<li><a href="tutorial.html">Tutorial</a></li>
				<li><a href="reference.html">Reference</a>
					<ul class="submenu">
						<li><a href="">Writing ST-JS code</a></li>
						<li><a href="">Controlling JS output</a></li>
						<li><a href="jslib.html">JS/DOM bridges</a></li>
						<li><a href="bridges.html">JS Library bridges</a></li>
						<li><a href="">Generator</a></li>
						<li><a href="maven.html">Maven plugin</a></li>
						<li><a href="eclipse.html">Eclipse integration</a></li>
						<li><a href="junit.html">JUnit runner</a></li>
					</ul></li>
				<li><a href="team.html">Team</a></li>
				<li><a href="http://axcraciun.wordpress.com/">Blog</a></li>
			</ul>
		</div>

		<div class="grid_10">
			<h3>Writing ST-JS code</h3>
			<p>Please start by reading our <a href="faq.html#whatDoesItLookLike">What does it look
				like?</a> section. It contains most of the information you need to write usual ST-JS
				code. On top of that, our <a href="tutorial.html">tutorial</a> will guide you through 
				all the steps necessary to create and run your first ST-JS project with Maven.</p>
			<p>If you need to use more advanced features of ST-JS, or haven't found out how 
				a particular JavaScript construct can be expressed in Java, then keep on reading.</p>


			<h4>Special fields and methods</h4>
			<p>Most of the Java code you write will be translated basically
				as-is to its JavaScript counterpart. However, there are some
				JavaScript constructs that cannot be written as-is in Java. For
				these cases, ST-JS provides workarounds as special fields and
				methods.</p>
			<p>All of those special fields and methods are easy to identify:
				there name always starts with the dollar sign ($). When you use
				these methods you should expect the generated JavaScript code to
				look slighty different (it is usually prettier, actually) than the
				corresponding Java construct.</p>
			<p>Here is the list of these constructs and methods:
			
			<h5>Collection initialization (org.stjs.javascript.JSCollections)</h5>
			<pre class="code prettyprint">
// JavaScript             // Java equivalent

// Create a map with the given keys and values
{k1:v1, k2:v2}            $map(k1,v1,k2,v2)

// Create an array with the given items
[a, b, c]                 $array(a, b, c)

// Convert a java array to the org.stjs.javascript.Array type
var a=b                   Array&lt;T&gt; a = $castArray(T[]b)
			</pre>
			
			<h5>Associative array, maps, etc... (org.stjs.javascript.Map)</h5>
			<pre class="code prettyprint">
// JavaScript             // Java equivalent

// Put a key and a value in a map
x[a] = b                  x.$put(a, b)

// Retrieve a value from a map
x[a]                      x.$get(a)

// Delete an entry from a map
delete x[a]               x.$delete(a)
			</pre>

			<h5>Arrays (org.stjs.javascript.Array)</h5>
			<pre class="code prettyprint">
// JavaScript             // Java equivalent

// Retrieve an item from an array
x[a]                      x.$get(a)

// Modify an item in an array
x[index] = val            x.$set(index, val)
			</pre>

			<h5>Working with object properties (org.stjs.javascript.JsObjectAdapter)</h5>
			<pre class="code prettyprint">
// JavaScript             // Java equivalent

// expose all the properties of an object as a map
propsMap = obj            propsMap = $properties(obj)

// get the value of a property of an object by name
obj["prop"]               $properties(obj).$get("prop")

// convert a map as an object of a given type with the same properties
var obj = map             T obj = $object(map)

// Return the prototype of a JavaScript objects
obj.prototype             $prototype(obj)

// Return the constructor of a JavaScript object
obj.constructor           $constructor(obj)

// Replaces with the given javascriptCode (only String literals accepted). 
// Use it only in extreme cases as it makes it impossible to minimize the code.
javascriptCode            $js(javascriptCode)
			</pre>

			<h5>Other Javascript operations (org.stjs.javascript.Global)</h5>
			<pre class="code prettyprint">
// JavaScript             // Java equivalent

// Return first value the is equivalent to true in JavaScript
a || b || c               $or(a,b,c)
			</pre>


			<h3>Controlling the JavaScript output</h3>
			<p>In most cases, there is no need to change the way the
				JavaScript is generated. There are however come cases where this is
				useful</p>
			<p>ST-JS lets you customize the way the JavaScript is generated
				(if you want to). You can give hints to the generator by placing
				annotations in your Java code.</p>
				
				
			<h4>@Namespace</h4>
			<p>The annotated Class, or all the classes in the annotated package
				will be placed in the specified namespace. This is useful to avoid
				name clashes with classes coming from other libraries.</p>

			<div class="grid_5 alpha">
<pre class="code prettyprint language-java">
// Java with @Namespace
@Namespace("genie.in.a")
public class Bottle {
    public Bottle() {
        doSomething();
    }
}

// Java without @Namespace
public class Plain {
    public Plain() {
        doNothing();
    }
}
</pre>
			</div>
			<div class="grid_5 omega">
<pre class="code prettyprint language-javascript">
// JavaScript with @Namespace
stjs.ns("genie.in.a");

genie.in.a.Bottle = function() {
    doSomething();
}


// JavaScript without @Namespace

Plain = function() {
    doNothing();
}
</pre>
			</div>
			<div class="clear"></div>
			


			<h4>@JavascriptFunction</h4>
			<p>All the anonymous implementations of the annotated single-method Java interface 
			will be generated as a JavaScript anonymous function. All invocations of the method
			contained in the annotated interface will be generated as a direct call to that function.
			The interface itself will not be generated in Javascript
			
			
			<div class="grid_5 alpha">
<pre class="code prettyprint language-java">
// Java
@JavascriptFunction
public interface EventHandler {
    public boolean onEvent(Event evt);
}

public class Something {
    public Something(Event event){
        // defining a new anonymous implementation
        EventHandler handler = new EventHandler() {
            public boolean onEvent(Event evt){
                console.print(evt.name);
            }
        };
        
        // calling the single-method
        handler.onEvent(event);
    }
}
</pre>
			</div>
			<div class="grid_5 omega">
<pre class="code prettyprint language-javascript">
// JavaScript 


// the interface is not generated



Something = function(event){
    // translated as an anonymous function
    var handler = function(evt) {

        console.print(evt.name);
        
    };
    
    // invoke the function directly
    handler(event);
}
</pre>
			</div>
			<div class="clear"></div>
			
			<h4>@GlobalScope</h4>
			<p>The static fields and methods in the annotated type are considered
				already being part of the global scope at runtime, typically provided by 
				an existing imported JavaScript library. When a type is 
				annotated with @GlobalScope, no corresponding JavaScript is generated.
			</p>
			<p>This annotation is useful when writing bridges for an existing JavaScript 
				library which declares some of its members in the global scope (typical 
				example: the $ identifier for JQuery). org.stjs.javascript.Global is an
				example of class with this annotation, which contains the declaration 
				of several global objects such as "window" or "console". 
			</p>

			<div class="grid_5 alpha">
<pre class="code prettyprint language-java">
// Java (declaration)
@GlobalScope
public class JQuerySubset {
    public static JQuery $;
    public static JQuery $(String selector) {
        // this doesn't need to be implemented
        // the real implementation comes 
        // directly from jquery.js
        throw new UnsupportedOperationException();
    }
}

// Java (usage)
import static JQuerySubset.$;

public class Something {
    public Something(){
        $(".hello").addClass(".world");
    }
}
</pre>
			</div>
			<div class="grid_5 omega">
<pre class="code prettyprint language-javascript">
// JavaScript (declaration)


// nothing is generated, implementation comes from
// including jquery.js







// JavaScript (usage)



Something = new function(){
    $(".hello").addClass(".world");
}
</pre>
			</div>
			<div class="clear"></div>


			<h4>@SyntheticType</h4>
			<p>The annotated class is marked as a data-only object. Objects marked with 
				this annotation can only contain non-private fields and cannot 
				contain any methods. Instance of a class marked with this annotation
				can be initialized using the double-brace syntax in your java source
				code, and will be translated to a Javascript Object Literal.
			</p>
			<p>This annotation is typically used by bridges to provide a correctly typed 
				equivalent of a parameter that the javscript library expects to be an 
				Object Literal. An example is AjaxParams used by JQuery.ajax</p>

			<div class="grid_5 alpha">
<pre class="code prettyprint language-java">
// Java (declaration)
@SyntheticType
public class AjaxParams {

    // some fields are omitted for brevity
    public boolean async;
    public String url;
}

// Java (usage)
import static JQuerySubset.$;

public class Something {
    public Something(){
        $.ajax(new AjaxParams(){{
            async = false;
            url = "http://example.com";
        }});
    }
}
</pre>
			</div>
			<div class="grid_5 omega">
<pre class="code prettyprint language-javascript">
// JavaScript (declaration)

var AjaxParams = function(){};
stjs.extend(AjaxParams, null, [], 
        function(constructor, prototype){
    prototype.async = null;
    prototype.url = null;
}, {});

// JavaScript (usage)



Something = function(){
    $.ajax({
        async : false,
        url : "http://example.com"
    });
}
</pre>
			</div>
			<div class="clear"></div>

			<h4>@STJSBridge</h4>
			<p>The annotated package or type is marked as a simple bridge between ST-JS
				Java source code and an existing JavaScript library. The purpose of types
				annotated (or contained withing packages that are annotated) with @STJSBridge
				is only to provide information about types, fields and methods contained 
				defined by an existing external JavaScript library to the Java tooling.
				</p>

			<h4>@Adapter</h4>
			<p>The static methods in the annotated are marked as being members of another 
				existing JavaScript type. This scope of this annotation is rather narrow, 
				and is used by ST-JS to make it possible to use all the methods that the 
				JavaScript standard library defines for types analog to those in the 
				java.lang package, such as Number(and its subclasses), String, Object, 
				etc...</p>
			<p>ST-JS tries to keep the Java code as close as possible to the generated
				JavaScript code, and therefore uses java.lang.Number (and subclasses) 
				and java.lang.String to represent the equivalent types of JavaScript.
				However, the member methods of each of these types are different in Java
				and in JavaScript. ST-JS hides this difference by providing JavaScript
				implementations of Java methods in stjs.js (when the Java method doesn't 
				exist in JavaScript), and by using @Adapter Java methods corresponding 
				to the JavaScript methods (when the JavaScript method doesn't exist in Java).
				</p>
			<p>For all the methods of an adapter class, the first parameter must be object 
				to which the method is applied. The other parameters are the parameters normally
				supplied to the JavaScript method.</p>

			<div class="grid_5 alpha">
<pre class="code prettyprint language-java">
// Java (declaration)
@Adapter
public class JSNumberAdapter {
  public static String toFixed(Number n, int p) {
    throw new UnsupportedOperationException();
  }

  public static String toPrecision(Number n, int p) {
    throw new UnsupportedOperationException();
  }
}

// Java (usage)
public class Something {
  public Something(int val){
    String fixed = JSNumberAdapter.toFixed(val, 2);
  }
}
</pre>
			</div>
			<div class="grid_5 omega">
<pre class="code prettyprint language-javascript">
// JavaScript (declaration)


// nothing is generated. The implementation is 
// already provided by the bridged library







// JavaScript (usage)

Something = function(val){
    var fixed = val.toFixed(2);
}
</pre>
			</div>
			<div class="clear"></div>


			<h4>@Template</h4>
			<p>this annotation can be used on a method to control how the
				call to this method will be generated. The parameter taken by this
				annotation is a name of a defined template. Currently only
				@Template("none") is defined, that leaves a method call as-is.
				object.$get(i) for example will generate object.$get(i) instead of
				object[i].</p>



			<h4>Special methods (ie: what is $length() for)</h4>
			<p>Sometimes it is more convenient to write STJS bridges as Java 
				interfaces rather than Java classes. This is how we decided to write
				the jQuery bridge, for example. When writing such a bridge using interfaces
				you quickly hit a problem: you need to expose an instance field within 
				the interface. As you know, this is impossible to do in java. You would want
				to do this:</p>

			<div class="grid_5 alpha">
<pre class="code prettyprint language-java">
// Java bridge
public interface A {
    public int field; //&lt; Illegal, oops...
    public String method();
}
</pre>
			</div>
			<div class="grid_5 omega">
<pre class="code prettyprint language-javascript">
// JavaScript source (bridged lib)
var A = {
    field: null,
    method: function(){}
}
</pre>
			</div>
			<div class="clear"></div>

			<p>As you probably know, it is impossible to place a field in an interface in
				Java. ST-JS provides a workaround by translating methods whose names start 
				with a $ sign as a field. Therefore, the previous case could be solved that
				way.</p>

			<div class="grid_5 alpha">
<pre class="code prettyprint language-java">
// Java bridge (declaration)
public interface A {
    /** Legal */
    public int $field(); 
    /** Legal. Don't add, if the field is read-only*/
    public void $field(int s); 
    public String method();
}

// Java application code (usage)
public class App {
    public App(A a){
        a.$field(42);
        String b = a.$field();
    }
}
</pre>
			</div>
			<div class="grid_5 omega">
<pre class="code prettyprint language-javascript">
// JavaScript source (bridged lib)
var A = {

    field : null,


    method : function(){}
}

// Generated JavaScript application code (usage)

App = function(a){
    a.field = 42;
    var b = a.field;
}
</pre>
			</div>
			<div class="clear"></div>

			<p>This works well in some cases, but not all. There are several javascript
				libraries out there that actually define methods that start with a $ sign,
				and you want you java code to properly reflect that without translating
				the method to a field access. In this case, just mark the affected methods
				with @Template("none").</p>

			<div class="grid_5 alpha">
<pre class="code prettyprint language-java">
// Java bridge (declaration)
public interface B {
    @Template("none")
    public String $method();
}

// Java application code (usage)
public class App {
    public App(B b){
        int val = b.$method();
    }
}
</pre>
			</div>
			<div class="grid_5 omega">
<pre class="code prettyprint language-javascript">
// JavaScript source (bridged lib)
var B = {

    $method : function(){}
}

// Generated JavaScript application code (usage)

App = function(b){
    var val = b.$method();
}
</pre>
			</div>
			<div class="clear"></div>

			<p>In the next major version we'd like to use the @Template
				mechanism instead of the method's name in order to control how the
				code is generated.</p>


			<h3>The JavaScript and DOM bridge libraries</h3>

			<p>The JavaScript library (js-lib) is a Java library that you need as 
				a compile-time dependency for the Java source code. This library
				exposes a conveniently exposes a properly typed version of the standard
				JavaScript library and DOM objects as defined by the browsers. The
				maven dependency for this library is the following:</p>

<pre class="code prettyprint language-xml">
&lt;dependency&gt;
  &lt;groupId&gt;org.st-js&lt;/groupId&gt;
  &lt;artifactId&gt;js-lib&lt;/artifactId&gt;
  &lt;version&gt;${stjs.version}&lt;/version&gt;
&lt;/dependency&gt;
</pre>

			<p>ST-JS also comes with another Java library that allows you to share
				objects easily between your client (JavaScript) app and you server (Java) by
				providing concrete java implementations of some of the classes in the 
				org.stjs.javascript package (such as Array and Map). The maven dependency for
				this library is the following</p>

<pre class="code prettyprint language-xml">
&lt;dependency&gt;
  &lt;groupId&gt;org.st-js&lt;/groupId&gt;
  &lt;artifactId&gt;server&lt;/artifactId&gt;
  &lt;version&gt;${stjs.version}&lt;/version&gt;
&lt;/dependency&gt;
</pre>

			<p>This dependency allows you to create maps and arrays and to serialize them 
				(as JSON for example).</p>













			<div id="content">
				<h1>Documentation</h1>

				<h2>Maven plugin</h2>
				<p>You can activate separately the JavaScript generation for
					main sources and tests. Here are the goals of the maven plugin:
				<ul>
					<li><b>generate</b> - activate the generation for the main
						sources (in the "process-sources" phase)</li>
					<li><b>generate-test</b> - activate the generation for the
						test sources (in the "process-test-classes" phase)</li>
					<li><b>copy-js</b> - copies the JavaScript files (either
						generated or just bridged) from the dependencies to the final
						artifact (war file), so that they can be used in the web pages</li>
				</ul>
				There are some parameters that can be used to configure the plugin:
				<ul>
					<li><b>includes/include</b> - the path specifier describing
						for what Java source you want to generate JavaScript. It's the
						standard path Maven/Ant specifiers. Defaults to **.</li>
					<li><b>excludes/excludes</b> - the path specifier describing
						what Java source you want to exclude from the JavaScript generate.
						It's the standard path Maven/Ant specifiers. Defaults to ""
						(nothing).</li>
					<li><b>allowedPackages</b> - it's a list of Java packages that
						are allowed to be used inside the Java sources used for
						generation. A common usage is when you reserved in the Java
						sources a package for bridges to some JavaScript libraries. This
						package should than be excluded from the generation process.</li>
					<li><b>generateArrayHasOwnProperty</b> - true to generate
						inside each array iteration if (!array.hasOwnProperty(index))
						continue; in order to protect array iteration from the inclusion
						of the methods added to Array's prototype. Default value if true</li>
					<li><b>pack</b> - if true, a single JavaScript will be created
						containing all the generated JavaScript files in a correct order
						(follows the dependencies)</li>
				</ul>
				</p>

				<!-- ------------------------  -->
				<h2>STJS helper</h2>
				<p>The org.stjs.javascript.stjs.STJS interface is the bridge to
					the JavaScript code coming with the generator. It offers some
					helpers for different type inexistent in JavaScript:
				<ul>
					<li><b>boolean isEnum(obj)</b> - return true if the given
						JavaScript object is an enum entry (the JavaScript wrapper needed
						to allow the usage of Java enums)</li>
					<li><b>Exception exception(Object obj)</b> - allows you in
						Java to use any object as an exception. At runtime, the executed
						JavaScript code will return exactly the received parameter</li>
					<li><b>public &lt;T&gt; T parseJSON(String json,
							Class&lt;T&gt; clazz)</b> - parses a JSON string in a "type-safe"
						manner by creating the object hierarchy using the given type
						definition</li>
				</ul>
				</p>
				<!-- ------------------------  -->
				<h2>JUnit runner configuration</h2>

				<p>The STJS JUnit runner runs your unit tests in one or multiple
					browsers of your chosing. To do so, it builds an HTML page that
					includes all the necessary HTML and javascript necessary to execute
					your tests and return the result to JUnit. The HTML page that will
					be sent to the browser includes the following things:
				<ul>
					<li>The javascript version of all the classes that are being
						tested, as well as that of all classes they depend on.</li>
					<li>If any bridge class or interface is used, the javascript
						code that corresponds. For example, if the classes under test use
						jQuery 1.7.1, then jQuery-1.7.1.js is imported in the HTML page
						that is sent to the browser.</li>
					<li>If specified with the <b>@ScriptsBefore</b> or <b>@ScriptsAfter</b>
						annotations, a set of javascript files that are required for the
						tests to pass but that are not declared as a STJS bridge class or
						interface.
					</li>
					<li>If specified with the <b>@HtmlFixture</b> annotation, a
						fragment of HTML that is required for the tests to pass.
					</li>
				</ul>
				</p>

				<p>Before using the JUnit runner you have to add the dependency
					to your projects pom.xml:</p>
				<pre class="brush: xml">
&lt;dependency&gt;
  &lt;groupId&gt;org.st-js&lt;/groupId&gt;
  &lt;artifactId&gt;test-helper&lt;/artifactId&gt;
  &lt;version&gt;${stjs.version}&lt;/version&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</pre>

				<p>
					To activate the STJS JUnit runner you have to annotate your JUnit
					test classes this way: <b>@RunWith(STJSTestDriverRunner.class)</b>.
				</p>

				<p>
					Besides the standard JUnit annotations such as <b>@Test</b>, <b>@Before</b>,
					<b>@After</b>, the STJSTestDriverRunner supports several other
					custom annotations.
				</p>

				<ul>
					<li>
						<p>
							<b>@HtmlFixture</b> is an optional annotation that can be applied
							to your test class, and is used to force the STJSTestDriverRunner
							to include a specific HTML fragment on the page. If the fragment
							is short enough, it can be specified verbatim in the annotation.
						</p> <pre class="brush: java">
@RunWith(STJSTestDriverRunner.class)
@HtmlFixture("&lt;div id='importantContainer'&gt;&lt;/div&gt;")
public class TestSimpleFixture {
	...
}</pre>
						<p>If the fragment is longer the annotation can specify a path
							to a classpath resource that contains the HTML code. Then html
							fragment file will be looked up using
							ClassLoader.getResourceAsStream(). This means that
							STJSTestDriverRunner (trough the ClassLoader) will first attempt
							to find the file in your class path. If the file cannot be found
							in your classpath, then STJSTestDriverRunner will look for the
							file starting at the "document root" or your webapp, if any. For
							a typical maven project, this means it will first look in
							/target/WEB-INF/classes, and then in /target.</p> <pre
							class="brush: java">
@RunWith(STJSTestDriverRunner.class)
@HtmlFixture(url = "/SomeComplexHtmlFragment.html")
public class TestSimpleFixture {
	...
}</pre>
					</li>
					<li>
						<p>
							<b>@ScriptsBefore</b> and <b>@ScriptsAfter</b> are optional
							annotations that can be applied to your test class, and are used
							to force the STJSTestDriverRunner to include extra javascript
							files in the &lt;head&gt; section of the HTML page that is sent
							to the browser. Script files specified in <b>@ScriptsBefore</b>
							will be included in the HTML page before the class under test and
							all its dependencies. Script files specifed in <b>@ScriptsAfter</b>
							will be included in the HTML page after the class under test and
							all its dependencies.
						</p>
						<p>Each of the strings passed as a value to these annotations
							will be used verbatim in the generated HTML. This means that you
							can pass either a path to a javascript file that exists within
							your project, or one that resides on another domain.</p> <pre
							class="brush: java">
@RunWith(STJSTestDriverRunner.class)
@ScriptsBefore({"/someLibBefore.js"})
@ScriptsAfter({"http://example.com/someLibAfter.js"})
public class TestHelloWorld {
	...
}</pre>
						<p>Will generate the following fragment of HTML</p> <pre
							class="brush: xml">
&lt;head&gt;
  &lt;!-- contents of @ScriptsBefore --&gt;
  &lt;script src="/someLibBefore.js" type="text/javascript"&gt;&lt;/script&gt;
  
  &lt;!-- Class under test plus other stuff required by stjs  --&gt;
  &lt;script src="/stjs.js" type="text/javascript"&gt;&lt;/script&gt;
  &lt;script src="/HelloWorld.js" type="text/javascript"&gt;&lt;/script&gt;
  
  &lt;!-- contents of @ScriptsAfter --&gt;
  &lt;script src="http://example.com/someLibAfter.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;/head&gt;
</pre>
						<p>If the script passed to this annotation is a reference to a
							file defined in your project (ie: it doesn't start with a
							protocol handler such as http:, file:, ftp:, https:, etc...),
							then the script file will be looked up using
							ClassLoader.getResourceAsStream(). This means that
							STJSTestDriverRunner (trough the ClassLoader) will first attempt
							to find the file in your class path. If the file cannot be found
							in your classpath, then STJSTestDriverRunner will look for the
							file starting at the "document root" or your webapp, if any. For
							a typical maven project, this means it will first look in
							/target/WEB-INF/classes, and then in /target.</p>
					</li>
				</ul>

				<p>
					You can configure some of the test driver's parameters in a file
					called <b>stjs-test.properties</b> that must be placed the root of
					your class path. The properties supported by this file are the
					following:
				</p>

				<table class="methods">
					<tr>
						<th>property</th>
						<th>description</th>
					</tr>
					<tr>
						<td><b>stjs.test.config</b></td>
						<td>The classpath location of properties file that contains
							the stjs test driver configuration. Default value is
							"/stjs-test.properties"</td>
					</tr>
					<tr>
						<td><b>stjs.test.browsers</b></td>
						<td>A comma separated list of browsers on which to run the
							tests. A test is successful only if it has been run successfully
							on all the browsers in this list. See the table below for a
							description of the supported browsers. The default value is
							"desktopDefault".</td>
					</tr>
					<tr>
						<td><b>stjs.test.port</b></td>
						<td>the port opened by the test driver waiting for connection
							from the browsers. Default value is 8055</td>
					</tr>
					<tr>
						<td><b>stjs.test.wait</b></td>
						<td>the time (in seconds) the test driver waits for the
							number of configured browsers to connect. Default value is 10</td>
					</tr>
					<tr>
						<td><b>stjs.test.skipIfNoBrowser</b></td>
						<td>if this is true, if no browser was connected that it
							considers the tests as ignored (can be used in some batch
							processing, without failing completely the tests). Default value
							is false</td>
					</tr>
					<tr>
						<td><b>stjs.test.startBrowser</b></td>
						<td>if true, if after 2 seconds (normally check of the
							client's code check is 1 second) no browser connected to the test
							driver, it tries to start the system's default browser. This can
							only work is the Desktop.isDesktopSupported() check return true
							(so usually a developer's machine). Default value is true</td>
					</tr>
					<tr>
						<td><b>stjs.test.testTimeout</b></td>
						<td>the time (in seconds) the test driver waits for a test to
							return a result from the browser. Passed this time the test is
							considered failed. Default value is 2 seconds</td>
					</tr>
					<tr>
						<td><b>stjs.test.debug</b></td>
						<td>if this is true, debug information is displayed. Default
							value is false</td>
					</tr>
					<tr>
						<td><b>firefox.bin</b></td>
						<td>the path to the binary of firefox (see "firefox" in the
							table below)</td>
					</tr>
					<tr>
						<td><b>chrome.bin</b></td>
						<td>the path to the binary of Google Chrome or chromium (see
							"chrome" in the table below)</td>
					</tr>
					<tr>
						<td><b>phantomjs.bin</b></td>
						<td>the path to the binary of phantomjs (see "phantomjs" in
							the table below)</td>
					</tr>
				</table>
				<p>All these properties can be overridden by specifying them as
					system properties when launching the java vm. For example to force
					debug mode when launching the tests via Maven you can run `mvn test
					-Dstjs.test.debug=true`.</p>
				<p>The browsers that can be added to the stjs.test.browsers
					property are the following.</p>

				<table class="methods">
					<tr>
						<th colspan="2">Browsers that require a graphics system</th>
					</tr>
					<tr>
						<th>Name</th>
						<th>Description</th>
					</tr>
					<tr>
						<td><b>desktopDefault</b></td>
						<td>
							<p>Launches whichever browser is the default for the desktop
								on which the tests are running.</p>
							<p>On windows the browser is launched using
								Desktop.getDesktop().browse(). On other systems it is launched
								using the "xdg-open" utility. This browser might fail to launch
								on headless machines in some operating systems, for example a
								linux server without an X11 server.</p>
						</td>
					</tr>
					<tr>
						<td><b>firefox</b></td>
						<td>
							<p>Launches firefox.</p>
							<p>STJS will look in the common firefox installation
								directories to find the binary. If firefox is not installed in
								the standard location on your target system, you can specify the
								path of the binary in the firefox.bin property in
								"stjs-test.properties", in whichever file you specified in the
								stjs.test.config system property or on the command line.</p>
						</td>
					</tr>
					<tr>
						<td><b>chrome</b></td>
						<td>
							<p>Launches Goole Chrome (or chromium).</p>
							<p>STJS will look in the common chrome installation
								directories to find the binary. If chrome is not installed in
								the standard location on your target system, you can specify the
								path of the binary in the chrome.bin property in
								"stjs-test.properties", in whichever file you specified in the
								stjs.test.config system property or on the command line.</p>
						</td>
					</tr>
					<tr>
						<th colspan="2">Browsers that can run on headless systems</th>
					</tr>
					<tr>
						<th>Name</th>
						<th>Description</th>
					</tr>
					<tr>
						<td><b>rhino</b></td>
						<td>
							<p>Runs the tests in an instance of Rhino that is embedded in
								stjs' test runner.</p>
							<p>No additional software needs to be installed on the target
								system for this browser to run.</p>
						</td>
					</tr>
					<tr>
						<td><b>remote</b></td>
						<td>
							<p>Doesn't launch any browsers.</p>
							<p>It assumes that a browser is already running somewhere
								(potentially on a remote machine), and that this browsers
								periodically polls the stjs test runners HTTP port to fetch unit
								tests to run.</p>
						</td>
					</tr>
					<tr>
						<td><b>phantomjs</b></td>
						<td>
							<p>Launches all the tests in phantomjs.</p>
							<p>Phantomjs is a lightweight, headless browser based on
								webkit and V8. Phantomjs needs to be installed on the target
								system for this browser to run.</p>
							<p>STJS will look in the common phantomjs installation
								directories to find the binary. If phantomjs is not installed in
								the standard location on your target system, you can specify the
								path of the binary in the phantomjs.bin property in
								"stjs-test.properties", in whichever file you specified in the
								stjs.test.config system property or on the command line.</p>
						</td>
					</tr>
					<tr>
						<td><b>headlessFirefox</b></td>
						<td>
							<p>Only supported on systems that use an X11 server.</p>
							<p>This browser needs Xvfb and firefox to be installed on the
								target system. Xvfb (X Virutal Frame Buffer) is an X11 server
								that doesn't need any real graphics capability to run, and will
								happily run on servers that do not have a graphics card.</p>
							<p>This browser will first launch an instance of Xvfb, and
								then launch a firefox instance instructing it to use Xvfb as its
								display.</p>
							<p>Xvfb is expcted to be in your PATH. The path to the
								firefox binary can be configured in the same way as for the
								"firefox" browser.</p>
						</td>
					</tr>
					<tr>
						<td><b>headlessChrome</b></td>
						<td>Same as headlessFirefox but starts Google Chrome instead.</td>
					</tr>
				</table>

				<!-- ------------------------  -->
				<h2>JavaScript, DOM and jQuery documentation</h2>
				<p>STJS provides bridges for the basic JavaScript objects, the
					DOM objects, jQuery (1.6) and jQuery UI (1.8). The bridges follow
					as closely as possible their JavaScript counterpart. So for the
					moment, please use the documentation provided by other reference
					websites:
				<ul>
					<li>JavaScript and DOM - <a
						href="http://www.w3schools.com/jsref/default.asp" target="_blank">w3schools</a></li>
					<li>jQuery - <a href="http://docs.jquery.com" target="_blank">jQuery</a></li>
					<li>jQuery UI - <a href="http://jqueryui.com/demos/"
						target="_blank">jQuery UI</a></li>
				</ul>

				For JavaScript and DOM the global functions and objects (like
				setInterval or window) are found in the <b>org.stjs.javascript.Global</b>
				class.<br /> For jQuery, the $ object and function are found in the
				<b>org.stjs.javascript.jquery.GlobalJQuery</b> class.
				</p>








			</div>
		</div>

		<a href="https://github.com/st-js/st-js/"><img
			style="position: absolute; top: 0; left: 0; border: 0;"
			src="https://s3.amazonaws.com/github/ribbons/forkme_left_white_ffffff.png"
			alt="Fork me on GitHub"></a>
</body>
</html>


